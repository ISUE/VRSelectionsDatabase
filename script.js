
// //This is solely for testing Button onClick
// function myFunction() {
//     console.log("Here is the Scatterplot data ");
//     console.log(data);
//   }

var myScatter;

function MakeScatter(csv_path = "./data_website.csv") {

  var TITLE = 'Object selection scenarios in VR (t-SNE Feature Space)';
  var POINT_X = 'X'; // column name for x values in data.csv
  var POINT_X_PREFIX = ''; // prefix for x values, eg '$'
  var POINT_X_POSTFIX = ''; // postfix for x values, eg '%'

  var POINT_Y = 'Y'; // column name for y values in data.csv
  var POINT_Y_PREFIX = ''; // prefix for x values, eg 'USD '
  var POINT_Y_POSTFIX = ''; // postfix for x values, eg ' kg'

  var POINT_NAME = 'Application'; // point names that appear in tooltip
  var POINT_COLOR = 'color'; // eg `black` or `rgba(10,100,44,0.8)`
  var POINT_RADIUS = 5; // radius of each data point

  //Additional Fields/Features that will be retrieved per row of CSV
  var POINT_LINK = 'Timestamp'; // column name for
  var POINT_DESCRIPTION = 'Description'; // column name for
  var POINT_DIMENSIONS = 'Dimensions'; // column name for
  var POINT_REFERENCE_FRAME = 'Reference Frame'; // column name for
  var POINT_PROXIMITY = 'Proximity'; // column name for
  var POINT_INTERACTABLE = 'Interactable'; // column name for
  var POINT_INTERACTOR = 'Interactor'; // column name for
  var POINT_INDICATION = 'Indication'; // column name for
  var POINT_CONFIRMATION = 'Confirmation'; // column name for
  var POINT_OUTCOME = 'Outcome'; // column name for

  /////////////////////////////
  var X_AXIS = ''; // x-axis label, label in tooltip
  var Y_AXIS = ''; // y-axis label, label in tooltip

  var SHOW_GRID = true; // `true` to show the grid, `false` to hide

  // Read data file with random string generated by current time
  // to bypass browser cache, and create chart

  $.get(csv_path, { '_': $.now() }, function (csvString) {

    var rows = Papa.parse(csvString, { header: true }).data;

    var data = rows.map(function (row) {
      return {
        x: row[POINT_X],
        y: row[POINT_Y],
        name: row[POINT_NAME],
        link: row[POINT_LINK],
        description: row[POINT_DESCRIPTION],
        ui: row[POINT_DIMENSIONS],
        distance: row[POINT_PROXIMITY],
        referenceFrame: row[POINT_REFERENCE_FRAME],
        direction: row[POINT_INTERACTABLE],
        occlusion: row[POINT_INTERACTOR],
        selectionTechnique: row[POINT_INDICATION],
        hoverIndication: row[POINT_CONFIRMATION],
        selectionImmediacy: row[POINT_OUTCOME],
        color: row[POINT_COLOR]
      }
    })

    // Filterable features and their names between CSV and JS code
    // Dimensions
    // Reference Frame
    // Proximity
    // Interactable
    // Interactor
    // Indication
    // Confirmation
    // Outcome

    for (const filterKey in filterList) {
      if (filterKey === "Dimensions") {
        for (const filterValue of filterList[filterKey]) {
          console.log("Filtering out " + filterValue + " from " + filterKey);
          data = data.filter(function (point) {
            return point.ui !== filterValue;
          });
        }
      }

      if (filterKey === "Reference Frame") {
        for (const filterValue of filterList[filterKey]) {
          console.log("Filtering out " + filterValue + " from " + filterKey);
          data = data.filter(function (point) {
            return point.referenceFrame !== filterValue;
          });
        }
      }

      if (filterKey === "Proximity") {
        for (const filterValue of filterList[filterKey]) {
          console.log("Filtering out " + filterValue + " from " + filterKey);
          data = data.filter(function (point) {
            return point.distance !== filterValue;
          });
        }
      }

      if (filterKey === "Interactable") {
        for (const filterValue of filterList[filterKey]) {
          console.log("Filtering out " + filterValue + " from " + filterKey);

          data = data.filter(function (point) {
            return point.direction !== filterValue;
          });
        }
      }

      if (filterKey === "Interactor") {
        for (const filterValue of filterList[filterKey]) {
          console.log("Filtering out " + filterValue + " from " + filterKey);

          data = data.filter(function (point) {
            return point.occlusion !== filterValue;
          });
        }
      }

      if (filterKey === "Indication") {
        for (const filterValue of filterList[filterKey]) {
          console.log("Filtering out " + filterValue + " from " + filterKey);
          data = data.filter(function (point) {
            return point.selectionTechnique !== filterValue;
          });
        }
      }

      if (filterKey === "Confirmation") {
        for (const filterValue of filterList[filterKey]) {
          console.log("Filtering out " + filterValue + " from " + filterKey);
          data = data.filter(function (point) {
            return point.hoverIndication !== filterValue;
          });
        }
      }

      if (filterKey === "Outcome") {
        for (const filterValue of filterList[filterKey]) {
          console.log("Filtering out " + filterValue + " from " + filterKey);
          data = data.filter(function (point) {
            return point.selectionImmediacy !== filterValue;
          });
        }
      }
    }
    // console.log(data);
    // console.log("length of filtered data " + data.length);

    // var scatterChartData = {
    //   datasets: [{
    //     label: 'My First dataset',
    //     //backgroundColor: POINT_COLOR,
    //     data: data,
    //     pointRadius: POINT_RADIUS,
    //     pointHoverRadius: POINT_RADIUS + 2,
    //     pointBackgroundColor: function (context) {
    //       var index = context.dataIndex;
    //       var value = context.dataset.data[index];
    //       return value.color;
    //     }
    //   }]
    // };

    // var ctx = document.getElementById('container').getContext('2d');
    // var dataPointModal = new bootstrap.Modal(document.getElementById('dataPointModal'), {
    //   keyboard: false
    // });

    // if (myScatter) {
    //   myScatter.destroy();
    // }

    // myScatter = new Chart(ctx, {
    //   type: "scatter",
    //   data: scatterChartData,
    //   options: {
    //     title: {
    //       display: true,
    //       text: TITLE,
    //       fontSize: 14,
    //     },
    //     legend: {
    //       display: false, // TODO
    //     },
    //     scales: {
    //       xAxes: [{
    //         scaleLabel: {
    //           display: false,
    //           labelString: X_AXIS
    //         },
    //         gridLines: {
    //           display: SHOW_GRID,
    //         },
    //         ticks: {
    //           display: true,
    //           maxTicksLimit: 35,
    //           stepSize: 5,
    //           callback: function (value, index, values) {
    //             return POINT_X_PREFIX + value.toLocaleString() + POINT_X_POSTFIX;
    //           }
    //         }
    //       }],
    //       yAxes: [{
    //         scaleLabel: {
    //           display: false,
    //           labelString: Y_AXIS
    //         },
    //         gridLines: {
    //           display: SHOW_GRID,
    //         },
    //         ticks: {
    //           display: true,
    //           maxTicksLimit: 35,
    //           stepSize: 5,
    //           callback: function (value, index, values) {
    //             return POINT_Y_PREFIX + value.toLocaleString() + POINT_Y_POSTFIX;
    //           }
    //         }
    //       }]
    //     },
    //     tooltips: {
    //       displayColors: false,
    //       callbacks: {
    //         title: function (tooltipItem, all) {
    //           return [
    //             all.datasets[tooltipItem[0].datasetIndex].data[tooltipItem[0].index].name,
    //           ]
    //         },
    //         label: function (tooltipItem, all) {
    //           let item = all.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
    //           return [
    //             item.selectionTechnique,
    //             item.distance,
    //             item.referenceFrame,
    //             item.ui,
    //           ]
    //         }
    //       }
    //     },

    //     onClick: function (e) {
    //       // Get the data point that was clicked on
    //       var dataPoint = myScatter.getElementAtEvent(e);

    //       // print datapoint color

    //       const datasetIndex = dataPoint[0]._datasetIndex;
    //       const itemIndex = dataPoint[0]._index;
    //       var value = myScatter.data.datasets[datasetIndex].data[itemIndex];

    //       console.log(value.color);
    //       // console.log(value.link);

    //       document.getElementById('feature1.AppName').innerText = value.name;
    //       document.getElementById('feature3.Description').innerText = value.description;
    //       document.getElementById('feature4.UI').innerText = value.ui;
    //       document.getElementById('feature5.SpeedAccuracy').innerText = value.speedAccuracy;
    //       document.getElementById('feature6.NumSelectable').innerText = value.numSelectable;
    //       document.getElementById('feature7.MaxNumSelectable').innerText = value.maxNumSelectable;
    //       document.getElementById('feature8.UniqueTarget').innerText = value.uniqueTarget;
    //       document.getElementById('feature9.Size').innerText = value.size;
    //       document.getElementById('feature10.Distance').innerText = value.distance;
    //       document.getElementById('feature11.StaticMoving').innerText = value.staticMoving;
    //       document.getElementById('feature12.Arrangement').innerText = value.arrangement;
    //       document.getElementById('feature13.ReferenceFrame').innerText = value.referenceFrame;
    //       document.getElementById('feature14.Direction').innerText = value.direction;
    //       document.getElementById('feature15.Occlusion').innerText = value.occlusion;
    //       document.getElementById('feature16.SelectionTechnique').innerText = value.selectionTechnique;
    //       document.getElementById('feature17.HoverIndication').innerText = value.hoverIndication;
    //       document.getElementById('feature18.SelectionImmediacy').innerText = value.selectionImmediacy;
    //       document.getElementById('feature19.LocomotionAlowed').innerText = value.locomotionAllowed;


    //       var button = document.getElementById('youtubeButton');
    //       var new_button = button.cloneNode(true);
    //       button.parentNode.replaceChild(new_button, button);

    //       new_button.addEventListener("click", function () {
    //         var youtubeLink = value.link;
    //         window.open(youtubeLink, "_blank");
    //       });

    //       dataPointModal.toggle();
    //     }
    //   }
    // });

  });
}

$(document).ready(MakeScatter("./data_website.csv"));


window.onscroll = function() {
  var button = document.getElementById("scrollToTop");
  if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
      button.style.display = "block";
  } else {
      button.style.display = "none";
  }
}

function scrollToTop() {
  window.scrollTo({
      top: 0,
      behavior: 'smooth'
  });
}
